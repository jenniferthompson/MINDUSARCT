---
title: "Primary In-Hospital Outcomes Analysis of the MIND-USA Clinical Trial"
output:
  html_notebook:
    theme: flatly
    highlight: tango
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
---

The MIND-USA clinical trial aims to define the role of antipsychotics in the management of delirium in critically ill patients, specifically comparing haloperidol (typical antipsychotic) and ziprasidone (atypical antipsychotic) to placebo. Further details can be found in the trial listing on [clinicaltrials.gov](https://clinicaltrials.gov/ct2/show/NCT01211522).

```{r setup, results = "hide"}
knitr::opts_chunk$set(message = FALSE)

suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(forcats))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(glue))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(captioner))
suppressPackageStartupMessages(library(rms))
suppressPackageStartupMessages(library(naniar))
suppressPackageStartupMessages(library(sparkline))
suppressPackageStartupMessages(library(ggthemr)) ## Github only; cttobin/ggthemr
suppressPackageStartupMessages(library(JTHelpers))
  ## Github only; jenniferthompson/JTHelpers

## Hmisc setup for nicely printing summaryM output
mu <- markupSpecs$html

## Helper functions
factor_tf <-
  function(x){ factor(as.numeric(x), levels = 1:0, labels = c("Yes", "No")) }
format_comma <- partial(format, big.mark = ",")
sum_na <- partial(sum, na.rm = TRUE)
q25 <- partial(quantile, probs = 0.25, na.rm = TRUE)
q50 <- partial(quantile, probs = 0.50, na.rm = TRUE)
q75 <- partial(quantile, probs = 0.75, na.rm = TRUE)
mean_na <- partial(mean, na.rm = TRUE)
sd_na <- partial(sd, na.rm = TRUE)
rndformat <- function(x, digits = 2){ format(round(x, digits), nsmall = digits) }
get_npct <- function(num, denom){
  sprintf("%s (%s%%)", num, round((num / denom) * 100))
}
describe_cont <- function(
  v_q50, v_q25, v_q75, v_mean, v_sd, dig_iqr = 0, dig_msd = 2
){
  sprintf(
    "%s [%s, %s]\\\n%s +/- %s",
    rndformat(v_q50, digits = dig_iqr),
    rndformat(v_q25, digits = dig_iqr),
    rndformat(v_q75, digits = dig_iqr),
    rndformat(v_mean, digits = dig_msd),
    rndformat(v_sd, digits = dig_msd)
  )
}

## Wrapper with my preferred options for printing summaryM objects
my_html <- function(sMobj, caption){
  html(
    sMobj,
    exclude1 = FALSE, long = TRUE, digits = 2, what = "%", npct = "both",
    prmsd = TRUE, brmsd = TRUE, middle.bold = TRUE,
    ## These options don't seem to be working.
    msdsize = mu$smaller2, outer.size = mu$smaller2, rowsep = TRUE,
    caption = caption
  )
}

## kable_styling wrapper to ensure all tables are consistently styled
mykablestyle <- function(obj, stripes = FALSE, ...){
  boptions <- c("hover", "responsive", "condensed", "bordered")
  if(stripes){ boptions <- c(boptions, "striped") }
  
  kable_styling(
    obj,
    bootstrap_options = boptions,
    full_width = FALSE,
    ...
  )
}

## -- ggplot palette/custom theme ----------------------------------------------
# ## Picked colors from/inspired by Flatly theme
# palette_colors <- c(
#   "dred"    = "#EA513B",
#   "dgreen"  = "#00BE9D",
#   "dblue"   = "#2595D6",
#   "dyellow" = "#F89B2F",
#   "lred"    = "#EF7A69",
#   "lgreen"  = "#00F1C7",
#   "lblue"   = "#4EAAE0",
#   "lyellow" = "#FAB360",
#   "dgray"   = "#2E3F4F",
#   "lgray"   = "#92A3A3"
# )

## Started with Flatly theme colors, moved to some I liked better
palette_colors <- c(
  "dpurple" = "#242249",
  "dred"    = "#B40F20",
  "dgray"   = "#2E3F4F",
  "dgreen"  = "#74A089",
  "dblue"   = "#1D77AB",
  "dyellow" = "#F89B2F",
  "lred"    = "#EF7A69",
  "lgreen"  = "#00F1C7",
  "lblue"   = "#4EAAE0",
  "lyellow" = "#FAB360",
  "lgray"   = "#92A3A3"
)

## Use ggthemr to define the full palette
mindusa_palette <- ggthemr::define_palette(
  swatch = as.character(palette_colors),
  gradient = c(
    lower = "#F8CD2F",
    upper = as.character(palette_colors["dblue"]))
)

## Set ggplot2 theme options directly
basetext_size <- 13
mindusa_theme <- function(base_size = basetext_size){
  theme_bw(base_size = base_size, base_family = "Lato") +
    theme(
      text = element_text(colour = as.character(palette_colors["dgray"])),
      plot.title = element_text(face = "bold"),
      plot.caption = element_text(face = "italic"),
      panel.grid.major = element_line(colour = "#E7E9E9"),
      panel.grid.minor = element_line(colour = "#F4F5F5"),
      legend.position = "bottom",
      legend.direction = "horizontal",
      strip.text = element_text(
        face = "bold", colour = as.character(palette_colors["dgray"])
      ),
      strip.background = element_rect(
        colour = as.character(palette_colors["dgray"]), fill = "#B9C3C4"
      )
    )
}

## Set final palette, theme
ggthemr(mindusa_palette)
theme_set(mindusa_theme())

# ## Test it out
# ggplot(data = iris, aes(x = Sepal.Length)) +
#   facet_wrap(~ Species) +
#   geom_histogram(aes(fill = Species), binwidth = 1) +
#   labs(
#     title = "This is a test plot",
#     subtitle = "With iris data.",
#     caption = "Everyone loves iris data."
#   )
# 
# ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
#   geom_point(aes(colour = Petal.Length)) +
#   labs(title = "Testing out continuous scale")

```

```{r orm_functions}
################################################################################
## Functions in this chunk are written by Qi Liu in conjunction with Liu et al:
## Liu Q, Shepherd BE, Li C, Harrell FE. Modeling continuous response variables
##   using ordinal regression. Statistics in Medicine 2017; 36: 4316-4335.
##
## At the time of analysis, source code can be found at
##   http://biostat.mc.vanderbilt.edu/wiki/pub/Main/ArchivedAnalyses/orm_code.r
## My only changes are to formatting/white space.
################################################################################

##-- Estimate conditional mean and its standard error for orm model ------------
mean.orm <- function(mod, new.data, se=TRUE){
  if(is.null(mod$yunique)) {
    stop("Need to set x=TRUE and y=TRUE for orm") 
  } else{
    order.y <- mod$yunique
    n.alpha <- length(order.y)-1
    xb <- as.matrix(new.data)%*%matrix(coef(mod)[colnames(new.data)])
    m.alpha <- mod$coef[1:n.alpha]
    lb <- t(outer(m.alpha, xb, "+")[,,1])
    m.s <- mod$trans$cumprob(lb)
    m.f <-
      t(apply(m.s, 1, FUN = function(x) c(1,x[1:n.alpha]) - c(x[1:n.alpha], 0)))
    m.mean <- apply(m.f, 1, FUN = function(x) sum(x*order.y))
    
    if(se){
      if(mod$family == "logistic"){
        mod$trans$deriv <- function(x) exp(-x)/(1+exp(-x))^2
      }
     
      dmean.dalpha <-
        t(apply(mod$trans$deriv(lb),
                1,
                FUN = function(x){
                  x*(order.y[2:length(order.y)] - order.y[1:n.alpha])
                }
        ))
      dmean.dbeta <- apply(dmean.dalpha, 1, sum)*as.matrix(new.data)
      dmean.dtheta <- cbind(dmean.dalpha, dmean.dbeta)   
      mean.var <-diag(dmean.dtheta%*%solve(mod$info.matrix)%*%t(dmean.dtheta))
      mean.se <- sqrt(mean.var)   
      result <- cbind(m.mean, mean.se)
      ci <- t(apply(result,
                    1,
                    FUN = function(x){
                      c(x[1]- qnorm(0.975)*x[2], x[1]+ qnorm(0.975)*x[2])
                    }))
      result <- cbind(result, ci)
      colnames(result) <- c("est", "se", "lb", "ub")
    } else{
      result <- matrix(m.mean)
      colnames(result) <- c("est")
    }
    
    return(result)
  } 
}

## -- Estimate conditional quantiles and confidence intervals for orm model ----
quantile.orm <- function(mod, new.data, probs = 0.5, se = TRUE){
  
  quantile <- matrix(NA, nrow=dim(new.data)[1], ncol=length(probs))
  order.y <- mod$yunique
  #n.alpha <- length(order.y)-1
  xb <- as.matrix(new.data)%*%matrix(coef(mod)[colnames(new.data)])
  alpha <- mod$coef[1:(length(unique(order.y))-1)]
  lb <- t(outer(alpha, xb, "+")[,,1])
  m.cdf <- 1- mod$trans$cumprob(lb)
  m.cdf <- cbind(0, m.cdf, 1)
  for(i in 1:length(probs)){
    try({
      index.1 <-
        apply(m.cdf, 1, FUN = function(x){ max(which(x <= probs[i]))[1]} )
      index.2 <-
        apply(m.cdf, 1, FUN = function(x){ min(which(x >= probs[i]))[1]} )
      
      index.y1 <- ifelse(index.1>length(order.y), Inf, order.y[index.1])
      index.y2 <- ifelse(index.2>length(order.y), Inf, order.y[index.2])
      
      index.y1.cdf <-
        ifelse(index.1 == 0, 0, m.cdf[cbind(1:dim(new.data)[1], index.1)])
      
      index.y2.cdf <- ifelse(index.2>length(order.y),
                             1,
                             m.cdf[cbind(1:dim(new.data)[1], index.2)])
      
      quantile[,i] <-
        ifelse(
          index.1 == index.2,
          index.y1,
          (index.y2-index.y1)/(index.y2.cdf - index.y1.cdf)*(probs[i]-index.y1.cdf) + index.y1)
      quantile[, i] <-
        ifelse(is.infinite(quantile[,i]), max(order.y), quantile[, i])
    })
  }
  result <- quantile
  
  if(se){
    if(mod$family == "logistic"){
      mod$trans$deriv <- function(x) exp(-x)/(1+exp(-x))^2
    }
    
    quantile.lb <- quantile.ub <-
      matrix(NA, nrow = dim(new.data)[1], ncol = length(probs))
    
    lb.se <- matrix(NA, ncol = dim(lb)[2], nrow = dim(new.data)[1])
    var <- as.matrix(solve(mod$info.matrix))
    
    for(i in 1:dim(lb)[2]){
      var.i <- var[c(i, which(names(coef(mod)) %in% colnames(new.data))), 
                   c(i, which(names(coef(mod)) %in% colnames(new.data)))]
      
      dcdf.dtheta <- cbind(-mod$trans$deriv(lb[,i]),  
                           -mod$trans$deriv(lb[,i])*as.matrix(new.data) )
      dlb.dtheta <- as.matrix(cbind(1, new.data))
      lb.se[,i] <- sqrt(diag(dlb.dtheta%*%var.i%*% t(dlb.dtheta)))
    }
    
    ci.lb <- sapply(
      1:dim(lb)[2],
      FUN = function(i){
        1- mod$trans$cumprob(lb[, i] +qnorm(0.975)*lb.se[, i])
      }
    )
    ci.ub <- sapply(
      1:dim(lb)[2],
      FUN = function(i) { 1- mod$trans$cumprob(lb[, i] -qnorm(0.975)*lb.se[, i])}
    )
    ci.lb <- matrix(ci.lb, nrow = dim(new.data)[1])
    ci.ub <- matrix(ci.ub, nrow = dim(new.data)[1])
    
    ci.lb <- cbind(0, ci.lb, 1)
    ci.ub <- cbind(0, ci.ub, 1)
    
    for(i in 1: length(probs)){
      try({
        index.1 <- apply(ci.lb, 1, FUN=function(x){ max(which(x<=probs[i]))[1]} )
        index.2 <- apply(ci.lb, 1, FUN=function(x){ min(which(x>=probs[i]))[1]} )
 
        index.y1 <- ifelse(index.1>length(order.y), Inf, order.y[index.1])
        index.y2 <- ifelse(index.2>length(order.y),Inf,order.y[index.2])
        
        index.y1.cdf <- ifelse(index.1==0, 0, ci.lb[cbind(1:dim(new.data)[1], index.1)])
        
        index.y2.cdf <- ifelse(
          index.2 > length(order.y), 1, ci.lb[cbind(1:dim(new.data)[1], index.2)]
        )

        quantile.lb[,i] <- ifelse(
          index.1 == index.2,
          index.y1,
          (index.y2-index.y1)/(index.y2.cdf - index.y1.cdf)*(probs[i]-index.y1.cdf) + index.y1
        )
        quantile.lb[, i] <-
          ifelse(is.infinite(quantile.lb[,i]), max(order.y), quantile.lb[, i])
        
        index.1 <- apply(ci.ub, 1, FUN=function(x){ max(which(x<=probs[i]))[1]} )
        index.2 <- apply(ci.ub, 1, FUN=function(x){ min(which(x>=probs[i]))[1]} )
        
        index.y1 <- ifelse(index.1>length(order.y), Inf, order.y[index.1])
        index.y2 <- ifelse(index.2>length(order.y),Inf,order.y[index.2])
        
        index.y1.cdf <- ifelse(
          index.1 == 0, 0, ci.ub[cbind(1:dim(new.data)[1], index.1)]
        )
        
        index.y2.cdf <- ifelse(
          index.2 > length(order.y), 1, ci.ub[cbind(1:dim(new.data)[1], index.2)]
        )
        
        quantile.ub[,i] <- ifelse(
          index.1 == index.2,
          index.y1, 
          (index.y2-index.y1)/(index.y2.cdf - index.y1.cdf)*(probs[i]-index.y1.cdf) + index.y1
        ) 
        quantile.ub[, i] <-
          ifelse(is.infinite(quantile.ub[,i]), max(order.y), quantile.ub[, i])
      })
    }
    
    result <- list(quantile = quantile,
                   lb = quantile.ub,
                   ub = quantile.lb)
  }
  
  return(result)
}


## -- Estimate conditional CDF and its standard error for orm models -----------
cdf.orm <- function(mod, new.data, at.y = 0, se = TRUE){
  if(is.null(mod$yunique)) {
    stop("Need to set x=TRUE and y=TRUE for orm") 
  } else{
    order.y <- mod$yunique
    xb <- as.matrix(new.data)%*%matrix(coef(mod)[colnames(new.data)])
    
    index <- sapply(
      at.y,
      FUN = function(x){
        if(x < min(order.y)[1]) result <- Inf 
        else if(x == min(order.y)[1]) result <- 1
        else if(x >= max(order.y)[1]) result <- -Inf
        else which(order.y >= x)[1]-1
      }
    )
    
    m.alpha <- mod$coef[index]
    m.alpha <- ifelse(is.infinite(index), index, m.alpha)
    if(length(at.y) == 1){
      lb <- as.matrix(outer(m.alpha, xb, "+")[,,1])
    } else lb <- t(outer(m.alpha, xb, "+")[,,1])
    m.cdf <- 1- mod$trans$cumprob(lb)
    
    if(se){
      if(mod$family == "logistic") mod$trans$deriv <- function(x) exp(-x)/(1+exp(-x))^2
      cdf.se <- matrix(NA, ncol = length(at.y), nrow = dim(new.data)[1])
      lb.se <- matrix(NA, ncol = length(at.y), nrow = dim(new.data)[1])
      
      var <- as.matrix(solve(mod$info.matrix))
      
      for(i in 1:length(at.y)) {
        var.i <- var[c(index[i], which(names(coef(mod)) %in% colnames(new.data))), 
                     c(index[i], which(names(coef(mod)) %in% colnames(new.data)))]
        dcdf.dtheta <- cbind(-mod$trans$deriv(lb[,i]),  
                             -mod$trans$deriv(lb[,i])*as.matrix(new.data) )
        dlb.dtheta <- as.matrix(cbind(1, new.data))
        cdf.se[,i] <- sqrt(diag(dcdf.dtheta %*% var.i%*% t(dcdf.dtheta)))
        lb.se[, i] <- sqrt(diag(dlb.dtheta%*%var.i%*% t(dlb.dtheta)))
      }
      
      ci.lb <- sapply(
        1:length(at.y),
        FUN=function(i) { 1- mod$trans$cumprob(lb[, i] +qnorm(0.975)*lb.se[, i])}
      )
      ci.ub <- sapply(
        1:length(at.y),
        FUN=function(i) { 1- mod$trans$cumprob(lb[, i] -qnorm(0.975)*lb.se[, i])}
      )

      result <- list(est = m.cdf,
                     se = cdf.se,
                     lb = ci.lb,
                     ub = ci.ub)
    } else{
      result <- list(est = m.cdf)
    }
    
    return(result)
  } 
}

```

```{r captions, results = "hide"}
## -- Table and figure captions ------------------------------------------------
table_nums <- captioner(prefix = "Table")
fig_nums <- captioner(prefix = "Figure")

table_nums(
  name = "screening", caption = "Overview of Screening, Exclusions & Randomization"
)
table_nums(name = "exclusions", caption = "Study Exclusions")
table_nums(name = "exc_other", caption = "'Other' Exclusions")
table_nums(
  name = "baseline_all",
  caption = "Demographic & ICU Admission Characteristics, All Consented Patients"
)
table_nums(
  name = "baseline_trt",
  caption = "Demographic & ICU Admission Characteristics, Randomized Patients"
)
table_nums(
  name = "icursn_other", caption = "Descriptions of 'Other' ICU Admission Reasons"
)
table_nums(
  name = "inhosp_trt",
  caption = "Intervention Period Characteristics by Treatment Group"
)
table_nums(
  name = "intervention_pt", caption = "Description of Intervention by Patient"
)
table_nums(
  name = "intervention_dose",
  caption = "Description of Intervention by Study Drug Dose"
)
table_nums(
  name = "dose_held_other",
  caption = "Reasons for Temporary Study Drug Hold due to 'Other'"
)
table_nums(
  name = "dose_permdc_other",
  caption = "Reasons for Study Drug Discontinuation due to 'Other'"
)

table_nums('package_info', caption = "Software Details")

fig_nums(
  name = "dcfds_unadj",
  caption = "Delirium/Coma-Free Days by Treatment Group"
)

```

```{r data_setup, results = "hide"}
## Analysis datasets are stored in an .Rdata file, originally created and stored
##  by create_rctdata.R in ../MINDUSADataMgmt.
load("analysisdata/rct.Rdata")

```

# Screening, Consent, and Randomization

<hr>

Because this trial aims to describe the association between antipsychotics and treatment of delirium (rather than prevention), patients were required to be delirious prior to being randomized to study drug. In order to treat delirium immediately upon it being observed, however, patients (or their surrogates) were consented as soon as they met study inclusion criteria and were found not to meet exclusion criteria.

Upon consent, patients could be randomized any time in the following five days, provided: no exclusions were met within that time; the patient remained in the ICU; and they did eventually become delirious. Patients are considered "disqualified" if they left the ICU or the study (via discharge, death, or withdrawal) prior to experiencing delirium, or never experienced delirium in the five days following consent.

```{r prep_screen_table}
## -- Create a data frame with rows = various categories of patients -----------
## --  (screened, consented, etc), along with N, % of patients in each ---------

## Get total N in each category; result = df with 1 row, columns = categories
## This will be added to a "vertical" data.frame to use as denominators
screen_ns <- ptstatus_df %>%
  ## Only include patients who met screening criteria
  filter(screened) %>%
  ## Create indicators for each reason for disqualification; patients
  ## disqualified for meeting exclusion criteria are included in "excluded after
  ## consent" and will not be listed here
  mutate(
    dq_nodel = ifelse(!disqualified, NA, dq_reason == "No delirium within 5 days"),
    dq_icudc = ifelse(!disqualified, NA, dq_reason == "ICU discharge before delirium"),
    dq_diedwd = ifelse(!disqualified, NA, dq_reason == "Died/withdrew before delirium")
  ) %>%
  ## Select the categories we want
  dplyr::select(screened, excluded_imm, approached, refused, consented, excluded_later,
         disqualified, randomized, dq_nodel, dq_icudc, dq_diedwd,
         matches("^rand\\_")) %>%
  summarize_all(sum, na.rm = TRUE)

## Create data.frame for final table, starting with horizontal df
screen_table <- screen_ns %>%
  ## Transpose to one row per category
  gather(key = "status", value = "npts") %>%
  ## Add potential denominators from horizontal df (need to replicate original
  ##  to get the same number of rows)
  bind_cols(bind_rows(rep(list(screen_ns), nrow(.)))) %>%
  mutate(
    ## Determine appropriate denominator for each category %
    denom = ifelse(status %in% c("excluded_imm", "approached"), screened,
            ifelse(status %in% c("refused", "consented"), approached,
            ifelse(status %in% c("excluded_later", "randomized", "disqualified"),
                   consented,
            ifelse(substr(status, 1, 4) == "rand", randomized,
            ifelse(substr(status, 1, 2) == "dq", disqualified, NA))))),
    ## Calculate %
    pctpts = round((npts / denom) * 100),
    ## More informative statuses
    status_label = case_when(
      status == "screened"       ~ "Screened within 72 hours of meeting inclusion criteria",
      status == "excluded_imm"   ~ "Excluded immediately (details below)",
      status == "approached"     ~ "Staff approached patient/surrogate",
      status == "refused"        ~ "Patient/surrogate refused consent",
      status == "consented"      ~ "Consented for study",
      status == "excluded_later" ~ "Excluded after consent (details below)",
      status == "disqualified"   ~ "Ineligible for randomization",
      status == "randomized"     ~ "Randomized to study drug",
      status == "rand_mv"        ~ "Mechanical ventilation",
      status == "rand_nippv"     ~ "Non-invasive positive pressure ventilation (NIPPV)",
      status == "rand_shock"     ~ "Requiring treatment for shock",
      status == "dq_nodel"       ~ "No delirium in 5 days after consent",
      status == "dq_icudc"       ~ "ICU discharge prior to delirium",
      status == "dq_diedwd"      ~ "Died/withdrew prior to delirium",
      TRUE ~ status
    ),
    ## Create character string with N (%)
    npct = ifelse(is.na(pctpts), format_comma(npts),
                  sprintf("%s (%s%%)", format_comma(npts), pctpts))
  ) %>%
  dplyr::select(status_label, npct)

## When did screening take place? Find first and last month
screening_months <- ptstatus_df %>%
  dplyr::select(screened, exc_month, exc_year, enroll_month, enroll_year) %>%
  mutate(screen_month = ifelse(!is.na(exc_month), exc_month, enroll_month),
         screen_year = ifelse(!is.na(exc_year), exc_year, enroll_year)) %>%
  filter(screened & !is.na(screen_month)) %>%
  arrange(screen_year, screen_month) %>%
  slice(c(1, n())) %>%
  mutate(monthyr = paste(month.name[screen_month], screen_year))

first_month <- screening_months %>% slice(1) %>% pull(monthyr)
last_month <- screening_months %>% slice(n()) %>% pull(monthyr)

```

`r table_nums("screening", display = "cite")` presents patient flow information for the `r format_comma(sum_na(ptstatus_df$screened))` patients who were screened with 72 hours of meeting inclusion criteria. Screening took place between `r first_month` and `r last_month`.

### `r table_nums("screening")`

```{r print_screen_table}
screen_table %>%
  kable(format = "html", col.names = c("", "N (%)"), align = c("l", "r")) %>%
  mykablestyle %>%
  group_rows("Screened Patients", 2, 3) %>%
  group_rows("Approached Patients", 4, 5) %>%
  group_rows("Consented Patients", 6, 8) %>%
  group_rows("Reasons for Ineligibility", 9, 11) %>%
  group_rows("Organ Failures Present at Randomization", 12, 14) %>%
  row_spec(grep("^Randomized", screen_table$status_label), bold = TRUE)

```

Patients could have none, one, or two of the listed organ failures present at randomization; percentages will not add up to 100%.

### `r table_nums("exclusions")`

```{r prep_exclusions}
## Some exclusions aren't relevant for our purposes here:
## - Rapidly resolving organ failure, 72h eligibility period exceeded:
##     indicates patient did not meet screening criteria
## - Patient/surrogate refusal: not considered a study exclusion
## We're also interested in the *combined* version of some:
## - pregnancy + breast feeding (2a, 2b); look at exc_2 instead
## - all exclusions relating to time running out (9c, e, f); look at exc_9cef
exclusion_rsns <- paste0(
  "exc_",
  c("2_pregbf", "34_neuro", "5_torsadesqtc", "6_maintmeds", "7_nmsallergy",
    "8_death24", "9a_refusal_md", "9cef_time", "10_blind_lang", "11_prison",
    "12_coenroll", "13_iqcode", "14_screen", "99_other")
)

exc_table <- ptstatus_df %>%
  ## Select only exclusion indicators (overall + specific exclusions)
  dplyr::select(id, matches("^excluded\\_"), one_of(exclusion_rsns)) %>%
  
  ## Reshape to long format: one row per "time" of exclusion (ever, screening,
  ##  after consent)
  gather(key = "when", value = "excluded", excluded_imm:excluded_ever) %>%
  
  ## Count only patients who were actually excluded
  filter(excluded) %>%
  
  ## Get count of each exclusion by time point
  group_by(when) %>%
  summarise_at(vars(-id), sum_na) %>%
  ungroup %>%
  
  ## Reshape to long format: one row per time + exclusion
  gather(key = "exclusion", value = "nexc", matches("^exc\\_[0-9]+")) %>%
  
  mutate(
    ## Calculate % of exclusions at each time point for each possible exclusion
    pctexc = round((nexc / excluded) * 100),
    ## Formatting/text work
    npct = sprintf("%s (%s%%)", format_comma(nexc), pctexc),
    when = gsub("^excluded\\_", "", when),
    exclusion = case_when(
      exclusion == "exc_2_pregbf"      ~ "Pregnancy or breast feeding",
      exclusion == "exc_34_neuro"      ~ "Severe dementia or neurodegenerative disease",
      exclusion == "exc_5_torsadesqtc" ~ "History of Torsades or prolonged QTc",
      exclusion == "exc_6_maintmeds"   ~ "Maintenance therapy with antipsychotics/lithium",
      exclusion == "exc_7_nmsallergy"  ~ "History of NMS or allergy to study drugs",
      exclusion == "exc_8_death24"     ~ "Expected death within 24 hours",
      exclusion == "exc_9a_refusal_md" ~ "Attending physician refusal",
      exclusion == "exc_9cef_time"     ~ "No surrogate available within window",
      exclusion == "exc_10_blind_lang" ~ "Blind, deaf, or unable to speak English",
      exclusion == "exc_11_prison"     ~ "Incarceration",
      exclusion == "exc_12_coenroll"   ~ "Enrolled in a study ineligible for co-enrollment",
      exclusion == "exc_13_iqcode"     ~ "IQCODE score >= 4.5",
      exclusion == "exc_14_screen"     ~ "Screening failure",
      TRUE ~ "Other exclusion"
    )
  ) %>%
  dplyr::select(exclusion, when, npct) %>%
  spread(key = when, value = npct) %>%
  arrange(desc(as.numeric(gsub(",", "", gsub(" \\([0-9]+\\%\\)$", "", ever)))))

exc_colheads <- c(
  "Exclusion",
  sprintf("Ever\\\n(N = %s)", format_comma(sum_na(ptstatus_df$excluded_ever))),
  sprintf("At Screening\\\n(N = %s)", format_comma(sum_na(ptstatus_df$excluded_imm))),
  sprintf("After Consent\\\n(N = %s)", format_comma(sum_na(ptstatus_df$excluded_later)))
)

```

Exclusions could take place at the time of screening (vast majority), or after consent, if a patient was determined to have cognitive disability (indicated by an IQCODE score >= 4.5) or was discovered to have an exclusion criteria prior to randomization. For the `r format_comma(sum_na(ptstatus_df$excluded_ever))` patients excluded from MINDUSA, `r table_nums("exclusions", display = "cite")` presents exclusions:

1. At any point (column 1; % out of all exclusions)
1. At the time of screening (column 2; % out of all screening exclusions)
1. After consent (column 3; % out of all post-consent exclusions)

Patients could meet multiple exclusion criteria; therefore, column percentages may total more than 100%.

```{r print_exc_table}
exc_table %>%
  kable(format = "html", col.names = exc_colheads, align = c("l", rep("r", 3))) %>%
  mykablestyle(stripes = TRUE)

```

### `r table_nums("exc_other")`

To save space, reasons for "other" exclusions are collapsed. Click on `Details` below to view them.

<details>
```{r exc_other_table}
ptstatus_df %>%
  filter(exc_99_other) %>%
  dplyr::select(exc_other) %>%
  kable(format = "html", col.names = c("Explanation for 'other' exclusion"), align = c("l")) %>%
  mykablestyle

```

</details>

# Descriptions of the Cohorts

<hr>

Our study design was such that a substantial number of patients gave consent to be in the study, but were unable to be randomized. Thus, we describe demographics and ICU admission characteristics of all consented patients, comparing those randomized to those not randomized (`r table_nums("baseline_all", display = "cite")`), and then describe those characteristics, as well as the course of hospitalization, by treatment group among randomized patients only (`r table_nums("baseline_trt", display = "cite")` and `r table_nums("inhosp_trt", display = "cite")`).

## Randomized vs Non-Randomized Patients

Since no further information was collected on patients who were unable to be randomized, we can only describe demographic and ICU admission characteristics of these patients. `r table_nums("baseline_all", display = "cite")` describes these characteristics for both all consented patients, and separately for patients who were and were not able to be randomized.

### `r table_nums("baseline_all")`

**Note on the AUDIT:** This questionnaire was developed for administration to the patient directly; out of necessity, we often administered it to surrogates, leading to missing data if a surrogate was unsure about the answer to a particular question. We have therefore calculated the score in two different ways: 1) if any question is missing the total is missing; and 2) any missing questions are assumed to have a score of 0.

```{r baseline_all}
## Do things to make the table pretty: Factor version of rand. indicator, labels
ptsummary_all_df2 <- ptsummary_all_df %>%
  left_join(rand_df, by = "id") %>%
  mutate(
    randomized_f = factor(
      as.numeric(ptsummary_all_df$randomized),
      levels = 0:1,
      labels = c("Not Randomized", "Randomized")
    )
  ) %>%
  mutate_at(
    vars(enroll_mv, enroll_nippv, enroll_shock),
    funs(factor(as.numeric(.), levels = 0:1, labels = c("No", "Yes")))
  )
    
label(ptsummary_all_df2$enroll_mv) <- "On invasive MV at consent"
label(ptsummary_all_df2$enroll_nippv) <- "On NIPPV at consent"
label(ptsummary_all_df2$enroll_shock) <- "Treatment for shock at consent"
label(ptsummary_all_df2$age_consent) <- "Age at consent"
label(ptsummary_all_df2$gender) <- "Gender"
label(ptsummary_all_df2$race_cat) <- "Race"
label(ptsummary_all_df2$ethnicity) <- "Ethnicity"
label(ptsummary_all_df2$english_level) <- "Fluency in English"
label(ptsummary_all_df2$education) <- "Education"
label(ptsummary_all_df2$insurance) <- "Insurance"
label(ptsummary_all_df2$bmi) <- "BMI"
label(ptsummary_all_df2$home_antipsyc) <- "On antipsychotics prior to admission"
label(ptsummary_all_df2$charlson_total) <- "Charlson Comorbidities Index"
label(ptsummary_all_df2$iqcode_total_ph) <- "IQCODE total score"
label(ptsummary_all_df2$adl_total_ph) <- "Katz Activities of Daily Living total score"
label(ptsummary_all_df2$faq_total_ph) <- "Functional Activities Questionnaire total score"
label(ptsummary_all_df2$audit_total_ph_complete) <-
  "AUDIT total score; incomplete questions considered missing"
label(ptsummary_all_df2$audit_total_ph_partial) <-
  "AUDIT total score; incomplete questions considered normal"
label(ptsummary_all_df2$frailty_f) <- "CSHA Clinical Frailty Score"
label(ptsummary_all_df2$icu_rsn) <- "Primary reason for ICU admission"
label(ptsummary_all_df2$sofa_adm) <- "SOFA at ICU admission (imputed data)"
label(ptsummary_all_df2$cv_sofa_adm_f) <- "Cardiovascular SOFA at ICU admission"
label(ptsummary_all_df2$sofa_imp_consent) <- "SOFA on day of consent (imputed data)"
label(ptsummary_all_df2$cv_sofa_consent) <- "Cardiovascular SOFA on day of consent"
label(ptsummary_all_df2$apache_adm) <- "APACHE II at ICU admission"

## Formula we'll use for both demographic/admission tables
admit_formula_lhs <- "enroll_mv + enroll_nippv + enroll_shock + age_consent + gender + race_cat + ethnicity + english_level + education + iqcode_total_ph + adl_total_ph + faq_total_ph + audit_total_ph_complete + audit_total_ph_partial + frailty_f + insurance + bmi + home_antipsyc + charlson_total + frailty_f + icu_rsn + apache_adm + sofa_adm + cv_sofa_adm_f + sofa_imp_consent + cv_sofa_consent"

my_html(
  summaryM(as.formula(paste(admit_formula_lhs, "randomized_f", sep = " ~ ")),
           data = ptsummary_all_df2,
           overall = TRUE),
  caption = "Demographic & ICU Admission Characteristics of Consented Patients"
)

```

## Randomized Patients by Treatment Group

The following tables describe demographic and ICU admission characteristics (`r table_nums("baseline_trt", display = "cite")`) and in-hospital characteristics (`r table_nums("inhosp_trt", display = "cite")`) of all randomized patients.

### `r table_nums("baseline_trt")`

```{r baseline_trt}
my_html(
  summaryM(as.formula(paste(admit_formula_lhs, "trt", sep = " ~ ")),
           data = subset(ptsummary_all_df2, randomized)),
  caption = "Demographic & ICU Admission Characteristics of Randomized Patients"
)

```

### `r table_nums("icursn_other")`

To save space, reasons for "other" ICU admission among randomized patients are collapsed. Click on `Details` below to view them.

<details>
```{r icursn_other_table}
ptsummary_all_df %>%
  filter(randomized & icu_rsn == "Other") %>%
  dplyr::select(icu_rsn_other) %>%
  kable(format = "html", col.names = c("Explanation for 'other' ICU admission reason"), align = c("l")) %>%
  mykablestyle

```

</details>

### `r table_nums("inhosp_trt")`

Unless otherwise specified, quantities in this table reflect the 14 days including and following randomization (the "study period"). Additional notes:

- "Liberation from mechanical ventilation" variables apply only to patients who were on MV when randomized, or were placed on MV within the 24 hours following randomization.
- All time-to-event descriptions (eg, ICU length of stay) begin at the time of randomization and go through the entire hospitalization (even if the patient remained hospitalized after the intervention period).

```{r inhosp_trt}
## Which variables do we want for *all* drugs?
medsum_vars <- c("ever_int", "days_exp_int", "total_exp_int", "mean_exp_int")

inhosp_vars <- c(
  "sofa_imp_rand", "cv_sofa_rand", "ever_mv", "days_mv_exp", "mv_num",
  "int_num", "noninv_num", "on_mv_rand24", "ever_mvlib_rand24",
  "daysto_mvlib_exp", "sepsis", "stroke",
  paste("benzo", medsum_vars, sep = "_"),
  paste("opioid", medsum_vars, sep = "_"),
  paste("propofol", medsum_vars, sep = "_"),
  paste("halop", medsum_vars, sep = "_"),
  paste("zipras", medsum_vars, sep = "_"),
  paste("antipsyc", medsum_vars, sep = "_"),
  "sofa_imp_max_int", "sofa_imp_min_int", "sofa_imp_mean_int",
  "ever_del_int", "del_int_exp", "ever_coma_int", "coma_int_exp",
  "ever_delcoma_int", "delcoma_int_exp", "dcfd_int",
  "icu_los", "icu_readmit_number", "hosp_los", "dc_status", "hospdis_loc"
)

## Create new dataset with variable labels, factors
inhosp_desc_df <- ptsummary_df %>%
  mutate(
    ever_mv = factor_tf(ever_mv),
    on_mv_rand24 = factor_tf(on_mv_rand24),
    ever_mvlib_rand24 = factor_tf(ever_mvlib_rand24),
    benzo_ever_int = factor_tf(benzo_ever_int),
    opioid_ever_int = factor_tf(opioid_ever_int),
    propofol_ever_int = factor_tf(propofol_ever_int),
    dex_ever_int = factor_tf(dex_ever_int),
    halop_ever_int = factor_tf(halop_ever_int),
    zipras_ever_int = factor_tf(zipras_ever_int),
    antipsyc_ever_int = factor_tf(antipsyc_ever_int),
    ever_del_int = factor_tf(ever_del_int),
    ever_coma_int = factor_tf(ever_coma_int),
    ever_delcoma_int = factor_tf(ever_delcoma_int)
  )
label(inhosp_desc_df$sofa_imp_rand) <- "SOFA on day of randomization (imputed data)"
label(inhosp_desc_df$cv_sofa_rand) <- "Cardiovascular SOFA on day of randomization"
label(inhosp_desc_df$ever_mv) <- "Ever on mechanical ventilation (either type)"
label(inhosp_desc_df$days_mv_exp) <- "Days on mechanical ventilation"
label(inhosp_desc_df$mv_num) <- "Times MV initiated (either type)"
label(inhosp_desc_df$int_num) <- "Number of intubations"
label(inhosp_desc_df$noninv_num) <- "Times NIPPV initiated"
label(inhosp_desc_df$on_mv_rand24) <- "On MV at or within 24h of randomization"
label(inhosp_desc_df$ever_mvlib_rand24) <-
  "Ever successfully liberated from MV at randomization"
label(inhosp_desc_df$daysto_mvlib_exp) <-
  "Days to successful liberation from MV"
label(inhosp_desc_df$sepsis) <-
  "Met criteria for sepsis on or before Intervention Day 18"
label(inhosp_desc_df$stroke) <- "Had a stroke during hospitalization"
label(inhosp_desc_df$benzo_ever_int) <- "Received benzodiazepines"
label(inhosp_desc_df$benzo_days_exp_int) <-
  "Days received benzodiazepines, if at all"
label(inhosp_desc_df$benzo_total_exp_int) <-
  "Total dose of benzodiazepines, if any"
label(inhosp_desc_df$benzo_mean_exp_int) <-
  "Mean daily dose of benzodiazepines on days received"
label(inhosp_desc_df$opioid_ever_int) <- "Received opioids"
label(inhosp_desc_df$opioid_days_exp_int) <- "Days received opioids, if at all"
label(inhosp_desc_df$opioid_total_exp_int) <- "Total dose of opioids, if any"
label(inhosp_desc_df$opioid_mean_exp_int) <-
  "Mean daily dose of opioids on days received"
label(inhosp_desc_df$propofol_ever_int) <- "Received propofol"
label(inhosp_desc_df$propofol_days_exp_int) <- "Days received propofol, if at all"
label(inhosp_desc_df$propofol_total_exp_int) <- "Total dose of propofol, if any"
label(inhosp_desc_df$propofol_mean_exp_int) <-
  "Mean daily dose of propofol on days received"
label(inhosp_desc_df$dex_ever_int) <- "Received dexmedetomidine"
label(inhosp_desc_df$dex_days_exp_int) <- "Days received dexmedetomidine, if at all"
label(inhosp_desc_df$dex_total_exp_int) <- "Total dose of dexmedetomidine, if any"
label(inhosp_desc_df$dex_mean_exp_int) <-
  "Mean daily dose of dexmedetomidine on days received"
label(inhosp_desc_df$halop_ever_int) <- "Received open-label haloperidol"
label(inhosp_desc_df$halop_days_exp_int) <-
  "Days received open-label haloperidol, if at all"
label(inhosp_desc_df$halop_total_exp_int) <-
  "Total dose of open-label haloperidol, if any"
label(inhosp_desc_df$halop_mean_exp_int) <-
  "Mean daily dose of open-label haloperidol on days received"
label(inhosp_desc_df$zipras_ever_int) <- "Received open-label ziprasidone"
label(inhosp_desc_df$zipras_days_exp_int) <-
  "Days received open-label ziprasidone, if at all"
label(inhosp_desc_df$zipras_total_exp_int) <-
  "Total dose of open-label ziprasidone, if any"
label(inhosp_desc_df$zipras_mean_exp_int) <-
  "Mean daily dose of open-label ziprasidone on days received"
label(inhosp_desc_df$antipsyc_ever_int) <- "Received open-label antipsychotics"
label(inhosp_desc_df$antipsyc_days_exp_int) <-
  "Days received open-label antipsychotics, if at all"
label(inhosp_desc_df$antipsyc_total_exp_int) <-
  "Total dose of open-label antipsychotics, if any"
label(inhosp_desc_df$antipsyc_mean_exp_int) <-
  "Mean daily dose of open-label antipsychotics on days received"
label(inhosp_desc_df$sofa_imp_max_int) <- "Highest daily SOFA"
label(inhosp_desc_df$sofa_imp_min_int) <- "Lowest daily SOFA"
label(inhosp_desc_df$sofa_imp_mean_int) <- "Mean daily SOFA"
label(inhosp_desc_df$ever_del_int) <- "Experienced delirium"
label(inhosp_desc_df$del_int_exp) <- "Days of delirium"
label(inhosp_desc_df$ever_coma_int) <- "Experienced coma"
label(inhosp_desc_df$coma_int_exp) <- "Days of coma"
label(inhosp_desc_df$ever_delcoma_int) <- "Experienced delirium and/or coma"
label(inhosp_desc_df$delcoma_int_exp) <- "Days of delirium and/or coma"
label(inhosp_desc_df$dcfd_int) <- "Delirium/coma-free days (missing days imputed)"
label(inhosp_desc_df$icu_los) <- "Total length of ICU stay (entire hospitalization)"
label(inhosp_desc_df$icu_readmit_number) <-
  "Number of ICU readmissions during hospitalization"
label(inhosp_desc_df$hosp_los) <- "Total length of hospitalization"
label(inhosp_desc_df$dc_status) <- "Status at end of hospitalization"
label(inhosp_desc_df$hospdis_loc) <- "Hospital discharge location"

html(
  summaryM(
    as.formula(paste(paste(inhosp_vars, collapse = "+"), "trt", sep = " ~ ")),
    data = inhosp_desc_df,
    overall = TRUE
  ),
  exclude1 = FALSE, long = TRUE, digits = 2, what = "%", npct = "both",
  prmsd = TRUE, brmsd = TRUE, msdsize = mu$smaller2,
  middle.bold = TRUE, outer.size = mu$smaller2, rowsep = TRUE,
  caption = "Description of Intervention Period among Randomized Patients"
)

```

# Description of the Intervention

<hr>

Once randomized, patients could receive study drug for treatment of delirium for up to 14 days, up to twice per day (with a third dose in rare cases). Study drug could be held temporarily, either for delirium resolution or for other reasons, or permanently discontinued. `r table_nums("intervention_pt", display = "cite")` describes randomization, receipt of study drug, reasons for study drug hold or discontinuation, and status at the end of hospitalization for each of the three treatment groups. `r table_nums("intervention_dose", display = "cite")` describes all opportunities to receive study drug dose.

In both tables, quantities are represented as either `N (%)` or as `median [25th, 75th percentiles]`, followed by `mean +/- standard deviation`.

**Note** that temporary holds and permanent discontinuations listed below only include drug stopped for adverse clinical reasons; they do *not* include instances where study drug was not administered due to resolution of delirium or patient unavailability (including ICU discharge, death, study withdrawal, being off the floor, or being placed on comfort care measures/hospice).

## Intervention by Patient

[PLACEHOLDER TEXT TILL WE GET REAL TREATMENT GROUPS, ASSUMING TREATMENT MEANS NOTHING] Patients were approximately equally randomized to the three treatment groups, with each group receiving study drug approximately the same number of days and times. Rates of temporary hold and permanent discontinuation were equivalent among all treatment groups.

Among patients with study drug temporarily held, the most common reasons were oversedation and "other." Study drug was most often discontinued by request of the patient, family, or medical team.

### `r table_nums("intervention_pt")`

```{r prep_rand_table}
randtable_df <- rand_df %>%
  left_join(
    dplyr::select(ptstatus_df, id, randomized, died_inhosp, wd_inhosp, elig_fu),
    by = "id"
  ) %>%
  ## Add study drug info
  left_join(ptdrug_df, by = "id") %>%
  group_by(trt)

## Summarize variables that just need sums
rand_sums <- randtable_df %>%
  summarise_at(
    vars(randomized, ever_studydrug, ever_drug_held,
         matches("^ever\\_held\\_[a-z]+$"),
         ever_drug_permdc, matches("^permdc\\_[a-z]+$"),
         died_inhosp, wd_inhosp, elig_fu),
    funs(sum_na)
  )

## Summarize continuous variables
rand_cont <- randtable_df %>%
  summarise_at(
    vars(hrs_random_drug, num_drug_days, num_drug_doses, mean_drug_daily),
    funs(q25, q50, q75, "mean" = mean_na, "sd" = sd_na)
  )

## Recombine
rand_table <- left_join(rand_sums, rand_cont, by = "trt") %>%
  ## Calculate and create strings for table
  mutate(
    npct_studydrug = get_npct(ever_studydrug, randomized),
    npct_held = get_npct(ever_drug_held, ever_studydrug),
    npct_held_ae = get_npct(ever_held_ae, ever_drug_held),
    npct_held_dystonia = get_npct(ever_held_dystonia, ever_drug_held),
    npct_held_eps = get_npct(ever_held_eps, ever_drug_held),
    npct_held_other = get_npct(ever_held_other, ever_drug_held),
    npct_held_oversed = get_npct(ever_held_oversed, ever_drug_held),
    npct_held_refuseptfam = get_npct(ever_held_refuseptfam, ever_drug_held),
    npct_held_qtc = get_npct(ever_held_qtc, ever_drug_held),
    npct_held_refuseteam = get_npct(ever_held_refuseteam, ever_drug_held),
    npct_permdc = get_npct(ever_drug_permdc, ever_studydrug),
    npct_permdc_ae = get_npct(permdc_ae, ever_drug_permdc),
    npct_permdc_coma = get_npct(permdc_coma, ever_drug_permdc),
    npct_permdc_refuseteam = get_npct(permdc_refuseteam, ever_drug_permdc),
    npct_permdc_nms = get_npct(permdc_nms, ever_drug_permdc),
    npct_permdc_react = get_npct(permdc_react, ever_drug_permdc),
    npct_permdc_other = get_npct(permdc_other, ever_drug_permdc),
    npct_permdc_refuseptfam = get_npct(permdc_refuseptfam, ever_drug_permdc),
    npct_permdc_torsades = get_npct(permdc_torsades, ever_drug_permdc),
    npct_died = get_npct(died_inhosp, randomized),
    npct_wd = get_npct(wd_inhosp, randomized),
    npct_elig = get_npct(elig_fu, randomized),

    hrs_random_drug = describe_cont(
      hrs_random_drug_q50, hrs_random_drug_q25, hrs_random_drug_q75,
      hrs_random_drug_mean, hrs_random_drug_sd
    ),
    drug_days = describe_cont(
      num_drug_days_q50, num_drug_days_q25, num_drug_days_q75,
      num_drug_days_mean, num_drug_days_sd
    ),
    drug_doses = describe_cont(
      num_drug_doses_q50, num_drug_doses_q25, num_drug_doses_q75,
      num_drug_doses_mean, num_drug_doses_sd
    ),
    mean_drug_daily = describe_cont(
      mean_drug_daily_q50, mean_drug_daily_q25, mean_drug_daily_q75,
      mean_drug_daily_mean, mean_drug_daily_sd
    )
  ) %>%
  dplyr::select(trt, randomized, npct_studydrug, hrs_random_drug, drug_days, drug_doses,
         mean_drug_daily, npct_held, matches("^npct\\_held\\_"), npct_permdc,
         matches("^npct\\_permdc\\_"), npct_died, npct_wd, npct_elig) %>%
  gather(key = table_row, value = table_string, -trt) %>%
  spread(key = trt, value = table_string) %>%
  mutate(
    sort_order = case_when(
      table_row == "randomized" ~ 1,
      table_row == "npct_studydrug" ~ 2,
      table_row == "hrs_random_drug" ~ 3,
      table_row == "drug_days" ~ 4,
      table_row == "drug_doses" ~ 5,
      table_row == "mean_drug_daily" ~ 6,
      table_row == "npct_held" ~ 7,
      table_row == "npct_permdc" ~ 8,
      table_row == "npct_died" ~ 9,
      table_row == "npct_wd" ~ 10,
      table_row == "npct_elig" ~ 11,
      str_detect(table_row, "^npct\\_held\\_") ~ 12,
      str_detect(table_row, "^npct\\_permdc\\_") ~ 13,
      TRUE ~ 14),
    table_row = case_when(
      table_row == "randomized"              ~ "Randomized",
      table_row == "npct_studydrug"          ~ "Received >=1 dose study drug",
      table_row == "hrs_random_drug"         ~ "Hours between randomization and first dose given",
      table_row == "drug_days"               ~ "Days received study drug",
      table_row == "drug_doses"              ~ "Doses of study drug",
      table_row == "mean_drug_daily"         ~ "Mean daily dose of study drug (mL)",
      table_row == "npct_held"               ~ "Ever had study drug temporarily held",
      table_row == "npct_permdc"             ~ "Had study drug permanently discontinued",
      table_row == "npct_died"               ~ "Died in the hospital",
      table_row == "npct_wd"                 ~ "Withdrew from study in the hospital",
      table_row == "npct_elig"               ~ "Eligible for long-term follow-up",
      table_row == "npct_held_ae"            ~ "Adverse event",
      table_row == "npct_held_dystonia"      ~ "Dystonia",
      table_row == "npct_held_eps"           ~ "Extrapyramidal symptoms",
      table_row == "npct_held_other"         ~ "Other reason",
      table_row == "npct_held_oversed"       ~ "Oversedation",
      table_row == "npct_held_qtc"           ~ "Prolonged QTc",
      table_row == "npct_held_refuseptfam"   ~ "Patient/family refusal",
      table_row == "npct_held_refuseteam"    ~ "Medical team refusal",
      table_row == "npct_permdc_ae"          ~ "Adverse event",
      table_row == "npct_permdc_coma"        ~ "Coma due to structural brain damage",
      table_row == "npct_permdc_nms"         ~ "NMS",
      table_row == "npct_permdc_other"       ~ "Other reason",
      table_row == "npct_permdc_react"       ~ "DRESS",
      table_row == "npct_permdc_refuseptfam" ~ "Patient/family refusal",
      table_row == "npct_permdc_refuseteam"  ~ "Medical team refusal",
      table_row == "npct_permdc_torsades"    ~ "Torsades de pointes",
      TRUE ~ "")
  ) %>%
  arrange(sort_order) %>%
  dplyr::select(-sort_order)

```

```{r print_rand_table}
rand_table %>%
  kable(format = "html", col.names = c("", LETTERS[1:3]), align = c("l", rep("r", 3))) %>%
  mykablestyle %>%
  group_rows("Randomized Patients", 2, 10) %>%
  group_rows("Reasons Study Drug Temporarily Held", 11, 18) %>%
  group_rows("Reasons Study Drug Permanently Discontinued", 19, 26)

```

## Intervention by Dose

`r table_nums("intervention_dose", display = "cite")` describes the `r format(nrow(doses_df), big.mark = ",")` doses of study drug attempted during the course of the study. Study staff continued to document dose opportunities after permanent discontinuation; therefore, patients could have >1 dose in that category in this table.

[PLACEHOLDER TEXT TILL WE GET REAL TREATMENT GROUPS, ASSUMING TREATMENT MEANS NOTHING] About 75% of doses were successfully given in each of the three treatment groups, with rates of study drug hold and discontinuation approximately equal between groups. Pre-dose QTcs were also roughly equivalent between the three groups.

Oversedation was the most common reason for temporary hold by far; actual RASSes at the time of dose administration are listed in `r table_nums("intervention_dose", display = "cite")`. Refusal (patient, family, or medical team) was the most common reason for permanent discontinuation.

### `r table_nums("intervention_dose")`

```{r prep_dose_table}
## How many total doses in each treatment group?
doses_grp <- doses_df %>%
  ## Restrict to randomized patients and add treatment group
  right_join(rand_df, by = "id") %>%
  ## Only keep doses either given, or held/d/c'd due to adverse clinical reasons
  ## (excludes doses held due to patient unavailability)
  filter(drug_given | drug_held | drug_permdc) %>%
  group_by(trt) %>%
  summarise(doses_trt = n())

## Summarize variables that just need sums
dose_table <- doses_df %>%
  ## Restrict to randomized patients and add treatment group
  right_join(rand_df, by = "id") %>%
  ## Only keep doses either given, or held/d/c'd due to adverse clinical reasons
  ## (excludes doses held due to patient unavailability)
  filter(drug_given | drug_held | drug_permdc) %>%
  group_by(trt) %>%
  summarise(
    doses_given = sum_na(drug_given),
    doses_held = sum_na(drug_held),
    doses_permdc = sum_na(drug_permdc),
    type_initial = sum_na(dose_type == "Initial Starting Dose"),
    type_restart = sum_na(dose_type == "Restarting Dose"),
    type_increase = sum_na(dose_type == "Increased Dose"),
    type_decrease = sum_na(dose_type == "Decreased Dose"),
    type_maintmax = sum_na(dose_type == "Maintained at Maximum Dose"),
    type_maint = sum_na(dose_type == "Maintained"),
    type_other = sum_na(dose_type == "Other"),
    amt_025 = sum_na(dose_amt == 0.25),
    amt_050 = sum_na(dose_amt == 0.50),
    amt_100 = sum_na(dose_amt == 1.00),
    amt_200 = sum_na(dose_amt == 2.00),
    q25_preqtc = q25(pre_dose_qtc),
    q50_preqtc = q50(pre_dose_qtc),
    q75_preqtc = q75(pre_dose_qtc),
    mean_preqtc = mean_na(pre_dose_qtc),
    sd_preqtc = sd_na(pre_dose_qtc),
    held_qtc = sum_na(held_qtc),
    held_oversed = sum_na(held_oversed),
    rass_0 = sum_na(oversed_actual == "0"),
    rass_1 = sum_na(oversed_actual == "-1"),
    rass_2 = sum_na(oversed_actual == "-2"),
    rass_3 = sum_na(oversed_actual == "-3"),
    rass_4 = sum_na(oversed_actual == "-4"),
    rass_5 = sum_na(oversed_actual == "-5"),
    held_eps = sum_na(held_eps),
    held_dystonia = sum_na(held_dystonia),
    held_ae = sum_na(held_ae),
    held_refuseteam = sum_na(held_refuseteam),
    held_refuseptfam = sum_na(held_refuseptfam),
    held_other = sum_na(held_other),
    permdc_nms = sum_na(permdc_nms),
    permdc_react = sum_na(permdc_react),
    permdc_torsades = sum_na(permdc_torsades),
    permdc_coma = sum_na(permdc_coma),
    permdc_ae = sum_na(permdc_ae),
    permdc_refuseptfam = sum_na(permdc_refuseptfam),
    permdc_refuseteam = sum_na(permdc_refuseteam),
    permdc_other = sum_na(permdc_other)
  ) %>%
  ## Add total doses per treatment group; need these for denominators
  left_join(doses_grp, by = "trt") %>%
  ## -- Turn into a table ------------------------------------------------------
  ## Doses given
  mutate_at(
    vars(type_initial:amt_200), funs(get_npct(., denom = doses_given))
  ) %>%
  mutate(
    desc_preqtc = describe_cont(
      q50_preqtc, q25_preqtc, q75_preqtc, mean_preqtc, sd_preqtc
    )
  ) %>%
  ## Doses temporarily held
  mutate_at(vars(rass_0:rass_5), funs(get_npct(., denom = held_oversed))) %>%
  mutate_at(
    vars(held_qtc, held_oversed, held_eps:held_other),
    funs(get_npct(., denom = doses_held))
  ) %>%
  ## Doses permanently discontinued
  mutate_at(
    vars(permdc_nms:permdc_other), funs(get_npct(., denom = doses_permdc))
  ) %>%
  ## Do these last because we need the numeric versions for numerators
  mutate_at(
    vars(doses_given, doses_held, doses_permdc),
    funs(get_npct(., denom = doses_trt))
  ) %>%
  ## Transpose to one row per descriptor, with a column for each treatment group
  dplyr::select(trt, doses_trt, doses_given:doses_permdc, type_initial:amt_200,
         desc_preqtc, held_qtc:held_other, rass_0:rass_5,
         permdc_nms:permdc_other) %>%
  gather(key = table_row, value = dose_value, -trt) %>%
  spread(key = trt, value = dose_value) %>%
  ## Table formatting
  mutate(
    sort_order = case_when(
      table_row == "doses_trt" ~ 1,
      table_row == "doses_given" ~ 2,
      table_row == "doses_held" ~ 3,
      table_row == "doses_permdc" ~ 4,
      table_row == "amt_025" ~ 5,
      table_row == "amt_050" ~ 6,
      table_row == "amt_100" ~ 7,
      table_row == "amt_200" ~ 8,
      table_row == "type_initial" ~ 9,
      table_row == "type_restart" ~ 10,
      table_row == "type_decrease" ~ 11,
      table_row == "type_increase" ~ 12,
      table_row == "type_maint" ~ 13,
      table_row == "type_maintmax" ~ 14,
      table_row == "type_other" ~ 15,
      table_row == "desc_preqtc" ~ 16,
      table_row == "held_ae" ~ 17,
      table_row == "held_dystonia" ~ 18,
      table_row == "held_eps" ~ 19,
      table_row == "held_oversed" ~ 20,
      table_row == "held_qtc" ~ 21,
      table_row == "held_refuseptfam" ~ 22,
      table_row == "held_refuseteam" ~ 23,
      table_row == "held_other" ~ 24,
      table_row %in% paste0("rass_", 0:5) ~ 25,
      table_row == "permdc_ae" ~ 26,
      table_row == "permdc_coma" ~ 27,
      table_row == "permdc_nms" ~ 28,
      table_row == "permdc_react" ~ 29,
      table_row == "permdc_torsades" ~ 30,
      table_row == "permdc_refuseptfam" ~ 31,
      table_row == "permdc_refuseteam" ~ 32,
      table_row == "permdc_other" ~ 33,
      TRUE ~ 34
    ),
    table_row = case_when(
      table_row == "doses_trt" ~ "Dose Opportunities",
      table_row == "doses_given" ~ "Given",
      table_row == "doses_held" ~ "Temporarily held",
      table_row == "doses_permdc" ~ "Permanently discontinued",
      table_row == "amt_025" ~ "0.25 mL",
      table_row == "amt_050" ~ "0.50 mL",
      table_row == "amt_100" ~ "1.00 mL",
      table_row == "amt_200" ~ "2.00 mL",
      table_row == "type_initial" ~ "Initial starting dose",
      table_row == "type_restart" ~ "Restarting dose",
      table_row == "type_decrease" ~ "Decrease",
      table_row == "type_increase" ~ "Increase",
      table_row == "type_maint" ~ "Maintained (med. induced coma)",
      table_row == "type_maintmax" ~ "Maintained at max dose",
      table_row == "type_other" ~ "Other",
      table_row == "desc_preqtc" ~ "Pre-dose QTc",
      table_row == "held_ae" ~ "Adverse event",
      table_row == "held_dystonia" ~ "Dystonia",
      table_row == "held_eps" ~ "Extrapyramidal symptoms",
      table_row == "held_oversed" ~ "Oversedation",
      table_row == "held_qtc" ~ "Prolonged QTc",
      table_row == "held_refuseptfam" ~ "Patient/family refusal",
      table_row == "held_refuseteam" ~ "Medical team refusal",
      table_row == "held_other" ~ "Other",
      table_row == "rass_0" ~ "0",
      table_row %in% paste0("rass_", 1:5) ~
        paste0("-", gsub("^rass\\_", "", table_row)),
      table_row == "permdc_ae" ~ "Adverse event",
      table_row == "permdc_coma" ~ "Coma due to structural brain damage",
      table_row == "permdc_nms" ~ "NMS",
      table_row == "permdc_react" ~ "DRESS",
      table_row == "permdc_torsades" ~ "Torsades de pointes",
      table_row == "permdc_refuseptfam" ~ "Patient/family refusal",
      table_row == "permdc_refuseteam" ~ "Medical team refusal",
      table_row == "permdc_other" ~ "Other",
      TRUE ~ "fix this!"
    )
  ) %>%
  arrange(sort_order) %>%
  dplyr::select(-sort_order)

```

```{r print_dose_table}
dose_table %>%
  kable(format = "html", col.names = c("", LETTERS[1:3]), align = c("l", rep("r", 3))) %>%
  mykablestyle %>%
  group_rows("All Dose Opportunities", 2, 4) %>%
  group_rows("Doses Given", 5, 16) %>%
  group_rows("Doses Temporarily Held", 17, 24) %>%
  group_rows("Actual RASS for Doses Held due to Oversedation", 25, 30) %>%
  group_rows("Doses Permanently Discontinued", 31, 38)

```

## "Other" Reasons for Hold & Discontinuation

Explanations for study drug held (`r table_nums("dose_held_other", display = "cite")`) and discontinued (`r table_nums("dose_permdc_other", display = "cite")`) for "other" reasons are listed in the tables below. To save space, these tables are collapsed; click on `Details` to see them.

```{r prep_dose_other}
other_held_table <- doses_df %>%
  filter(held_other) %>%
  dplyr::select(held_other_exp)

other_permdc_table <- doses_df %>%
  filter(permdc_other) %>%
  dplyr::select(permdc_other_exp)

```

### `r table_nums("dose_held_other")`

<details>
```{r print_dose_held_other}
other_held_table %>%
  kable(format = "html", col.names = c("Explanation for 'other' study drug hold"), align = c("l")) %>%
  mykablestyle(stripes = TRUE)

```
</details>

### `r table_nums("dose_permdc_other")`

<details>
```{r print_dose_permdc_other}
other_permdc_table %>%
  kable(format = "html", col.names = c("Explanation for 'other' study drug discontinuation"), align = c("l")) %>%
  mykablestyle(stripes = TRUE)

```
</details>

## Safety Outcomes

Our three primary safety outcomes are neuroleptic malignant syndrome (NMS); Torsades de pointes (Torsades); and extrapyramidal symptoms (EPS). Incidence of each was minimal and is described below.

### NMS

```{r nms}
## How many patients experienced NMS at all? during intervention?
n_rand_nms_ih <- sum_na(ptsummary_df$ever_nms_ih)
n_rand_nms_int <- sum_na(ptsummary_df$ever_nms_int)

## In an ideal, reproducible world, we'd code text to account for all plausible
## scenarios, but we have a deadline and both the above are zero so we're just
## going to go with that because that data will not change at this point.

```

No randomized patients ever experienced NMS during the study (during or outside the intervention phase).

### Torsades de Pointes

During the intervention phase, `r sum_na(ptsummary_df$ever_torsades_any_int)` randomized patients experienced Torsades de pointes. Both instances were recorded as Serious Adverse Events; descriptions of both AEs are included below, with potentially identifying details redacted.

```{r torsades, results = "hide"}
torsades_df %>%
  kable(
    format = "html",
    col.names = c("ID", "Trt", "Study Phase", "Serious?", "Description")
  ) %>%
  mykablestyle()

```

### EPS

To describe and determine the presence of extrapyramidal symptoms (EPS), we used a modified version of the [Simpson-Angus Score](http://onlinelibrary.wiley.com/doi/10.1111/j.1600-0447.1970.tb02066.x/epdf) which included elbow and wrist rigidity, glabellar tap, resting tremor, and salivation. Patients were considered to have an official diagnosis of EPS if at least three out of these five symptoms had a score of 3 or higher on a given day; patients whose glabellar tap reflex could not be assessed were assigned a symptom score of 0. Details for the `r sum_na(ptsummary_df$ever_eps_int)` randomized patients who met this criteria at least once during the intervention period are shown below.

```{r eps}
ptsummary_df %>%
  filter(ever_eps_int) %>%
  dplyr::select(
    id, trt, days_eps_int, eps_score_mean_exp_int, ever_held_eps, times_held_eps
  ) %>%
  kable(
    format = "html",
    col.names = c(
      "ID", "Trt", "Days met EPS criteria", "Overall EPS Score when Criteria Met",
      "Study drug held for EPS?", "Doses held for EPS"
    )
  ) %>%
  mykablestyle()

```

# Exploration of Missing Data

We examine all outcomes and covariates to determine how much missing data is present. In short, we have no missingness for our outcomes and very little for our covariates; therefore, we will perform complete case analysis only. Expand the `Details` section below for further information.

```{r model_prep}
## -- Create dataset with only outcomes, covariates ----------------------------
outcome_vars <- c(
  "dcfd_int", "del_int_all", "coma_int_all",
  "tte_death_30", "event_death_30",   ## Time to death
  "tte_icudis_30", "event_icudis_30", ## Time to final, successful ICU discharge
  "tte_mvlib_30", "event_mvlib_30"    ## Time to liberation from MV
)

covariate_vars <- c(
  "age_consent", "charlson_total", "iqcode_total_ph", "frailty",
  "sofa_mod_imp_rand", "arousal_rand", "trt"
)

model_df <- ptsummary_df %>%
  dplyr::select(
    id, study_site, on_mv_rand24, rass_rand,
    one_of(outcome_vars), one_of(covariate_vars)
  ) %>%
  ## Create category for level of arousal at randomization,
  ##   using RASS closest to time of randomization within 5 hours
  mutate(
    arousal_rand = factor(
      case_when(
        is.na(rass_rand) ~ as.numeric(NA),
        rass_rand %in% c(-3) ~ 1,
        rass_rand %in% c(-2, -1) ~ 2,
        rass_rand %in% c(0) ~ 3,
        TRUE ~ 4
      ),
      levels = 1:4,
      labels = c("Deeply sedated", "Lightly sedated", "Normal", "Agitated")
    )
  )

## Set datadist to this data.frame
dd <- datadist(model_df)
options(datadist = "dd")

## -- Create sparklines to show distributions ----------------------------------
create_spark <- function(
  vname,                                 ## variable name; must be in df
  vbreaks = NULL,                        ## breaks to bin data, if desired
  spark_id = sprintf("spark-%s", vname), ## name of sparkline element
  spark_width = 50,                      ## sparkline width
  df = model_df                          ## data.frame to use
){
  if(is.null(vbreaks)){
    df$vcuts <- df[, vname]
  } else{
    df$vcuts <- cut(df[, vname], breaks = vbreaks)
  }
  
  barhts <- df %>%
    group_by(vcuts) %>%
    summarise(count = n())
  
  sparkline(
    barhts$count,
    type = "bar",
    barColor = as.character(palette_colors["dred"]),
    elementId = spark_id,
    width = spark_width
  )
}

spark_iqcode <- create_spark(
  "iqcode_total_ph",
  vbreaks = seq(0, 5, 0.25),
  spark_id = "spark-iqcode"
)

spark_dcfd <- create_spark(
  "dcfd_int",
  # vbreaks = seq(-1, 14, 1),
  spark_id = "spark-dcfd",
  spark_width = 50
)

## -- Create model RHS for multiple uses ---------------------------------------
## How many knots for continuous covariates? Which ones are continuous?
rcsknots <- 3
cont_covars <- c("age_consent", "charlson_total", "frailty", "sofa_mod_imp_rand")
notcont_covars <- setdiff(covariate_vars, cont_covars)

mod_rhs <- map_chr(cont_covars, ~ sprintf("rcs(%s, %s)", ., rcsknots)) %>%
  c(., notcont_covars) %>%
  paste(collapse = " + ")

## For testing purposes: RHS, no splines
mod_rhs_lin <- paste(covariate_vars, collapse = " + ")

```

<details>

```{r missing_allpts}
gg_miss_var(
  model_df %>%
    dplyr::select(-id, -rass_rand, -on_mv_rand24, -tte_mvlib_30, -event_mvlib_30),
  show_pct = TRUE
) +
  scale_y_continuous(name = "% Missing", limits = c(0, 5)) +
  geom_hline(yintercept = 5, colour = "gray50", linetype = "dotted") +
  labs(
    title = "Outcome and Covariate Missingness for Most Models",
    subtitle = "Includes all randomized patients"
  )

```

IQCODE and level of arousal at randomization are the only covariates with missing data; the amount is still quite minimal (<2%), and it is not missing in ways that appear to be related. In the plot below, red indicates missingness, blue indicates a present value. Cases which have both variables missing would be in red in the lower lefthand corner.

```{r iqcode_rass_miss}
ggplot(data = model_df) +
  geom_miss_point(aes(x = iqcode_total_ph, y = rass_rand),
                  position = position_jitter(height = 0.2), alpha = 0.5)

```

</details>

# Primary Outcome: Delirium/Coma-Free Days

<hr>

**Note**: We use single imputation to reduce bias from the `r round(mean(is.na(subset(daily_int_df, study_status == "Intervention")$mental_status_raw)) * 100)`% of patient-days during the intervention period without sufficient RASS and/or CAM information to determine mental status. Please see [Notes on Variable Calculation](#dcfds) for further rationale.

## Unadjusted Analysis

Our primary unadjusted analysis uses a Kruskal-Wallis test to look for any differences in distribution of DCFDs between the three treatment groups. *(The Kruskal-Wallis test is a nonparametric test analogous to the parametric ANOVA. The distribution of DCFDs is quite non-normal `r spark_dcfd`; thus a nonparametric test provides more power and reliability.)*

```{r dcfds_unadj, results = "hide"}
## -- Test DCFDs by treatment group --------------------------------------------
dcfd_kw <- with(ptsummary_df, kruskal.test(x = dcfd_int, g = trt))

## For caption: How many days are missing status which should have it?
miss_mental <- sum(
  is.na(
    subset(
      daily_int_df,
      study_day < 14 & study_status %in% c("Intervention", "Withdrawn")
    )$mental_status_raw
  )
)
days_inhosp <- nrow(
  subset(
    daily_int_df,
    study_day < 14 & study_status %in% c("Intervention", "Withdrawn")
  )
)
days_all <- nrow(subset(daily_int_df, study_day < 14))

## -- Plot DCFDs by treatment group; include K-W results as subtitle -----------
dcfd_plot <- ggplot(data = ptsummary_df, aes(x = dcfd_int)) +
  facet_wrap(~ trt, nrow = 1) +
  geom_histogram(aes(fill = trt), binwidth = 1) +
  scale_x_continuous(name = "Delirium/Coma-Free Days", breaks = seq(0, 14, 2)) +
  scale_y_continuous(name = "Patient Count") +
  theme(legend.position = "none",
        plot.caption = element_text(size = 10)) +
  labs(
    title = "Delirium/Coma-Free Days by Treatment Group",
    subtitle = glue(
      "Kruskal-Wallis test:\n",
      "X2, {rndformat(dcfd_kw$statistic, 2)}; ",
      "df, {dcfd_kw$parameter}; ",
      "P, {formatp(dcfd_kw$p.value)}"
    ),
    caption = glue(
      "\n\nAmong in-hospital days, {rndformat((miss_mental / days_inhosp) * 100, 0)}% had insufficient CAM and/or RASS available to determine mental status;\namong all days in the intervention period (including those after death or discharge), this percentage is {rndformat((miss_mental / days_all) * 100, 0)}%."
    )
  )

```

### `r fig_nums("dcfds_unadj")`

```{r print_dcfds_unadj, fig.width = 7.5, fig.height = 4}
dcfd_plot

```

## Adjusted Analysis

Using the same two versions of DCFDs, we perform multivariable regression analyses adjusting for potential baseline confounders. Though these covariates should be balanced between treatment groups thanks to randomization, adjustment increases our power and precision. Due to the distribution of DCFDs, we use proportional odds logistic regression, which is robust to non-normal distributions and works well for ordered outcomes.

### Covariates{#covariates}

Covariates for all multivariable regression models include:

- Age at study consent
- Preexisting CI, via the IQCODE (performed via patient or surrogate questionnaire)
- Preexisting frailty, via the CSHA Clinical Frailty Score
- Preexisting comorbidities, via the Charlson Comorbidities Index
- SOFA on the day of randomization, excluding the CNS component
- Level of arousal at randomization, via the RASS closest to the time of randomization

Age, CFS, and Charlson are all allowed to have a nonlinear relationship with our outcome, using restricted cubic splines with `r rcsknots` knots. The distribution of IQCODE `r spark_iqcode` (`r rndformat(mean_na(model_df$iqcode_total_ph == 3) * 100, 0)`% of patients had a score of exactly 3) has too little variability to allow this flexibility.

In addition, we adjust variances using Huber-White sandwich estimation clustered by study site. This will help account for unmeasured variability and correlation among patients within a given site.

### Redundancy Analysis

To make sure none of our covariates completely explain any of the others (resulting in collinearity), we perform a redundancy analysis, detailed below. No covariates suggest evidence of too-high collinearity.

<details>

```{r redundancy, results = "markup"}
Hmisc::redun(
  ~ age_consent + charlson_total + frailty + sofa_mod_imp_rand +
    I(iqcode_total_ph) + arousal_rand + trt,
  data = model_df,
  nk = rcsknots
)

```

</details>

### Model Fitting

```{r dcfds_adj, results = "hide"}
## Primary model fit using rms::orm(), because Liu & Shepherd have some nice
##  functions for getting means, etc from this. My function to check PO
##  assumption assumes rms::lrm() fit; one day I should make this flexible, but
##  for now, fit it twice. Results are identical when both use default options.
dcfd_mod <- orm(
  as.formula(paste("dcfd_int ~", mod_rhs)),
  data = model_df,
  x = TRUE, y = TRUE
) %>%
  robcov(cluster = model_df$study_site)

dcfd_mod_lrm <- lrm(
  as.formula(paste("dcfd_int ~", mod_rhs)),
  data = model_df,
  x = TRUE, y = TRUE
) %>%
  robcov(cluster = model_df$study_site)

```

### Model Assumptions

We graphically check our assumption of proportional odds, paying particular attention to treatment group. Something may be amiss if Y axis values (estimated coefficient at various cutoffs of our outcome) change substantially across the X axis, particularly if the effect changes direction (noted by the dotted line at 0). For further discussion, please see Harrell's *Regression Modeling Strategies*, 2nd ed, section 13.3.

<details>

```{r dcfds_assume}
JTHelpers::rms_po_assume(
  dcfd_mod_lrm,
  cuts = seq(1, 12, 1),
  modelData = model_df
) +
  labs(title = "PO assumption for DCFDs") +
  theme(axis.text = element_text(size = 8))

```

</details>

### Model Results

We show the odds ratios for DCFDs by treatment group, using placebo as our reference. Odds ratios higher than 1 are favorable, indicating higher odds of more "good" days alive and free of brain dysfunction.

TREATMENTS ARE ONCE AGAIN COMPLETELY FAKE

```{r dcfd_ors, fig.width = 5, fig.height = 3}
## Wrapper for rms_calc_comparisons that adds outcome variable as a column
## (Only tested on lrm fits)
lrm_comparisons_addoutcome <- function(rmsObj, ...){
  outcome <- gsub("()", "", rmsObj$sformula[2], fixed = TRUE)
  rms_calc_comparisons(rmsObj, ...) %>%
    mutate(outcome = outcome)
}

## -- Calculate odds ratios for both treatments vs placebo, both model fits ----
## Result = tidy data frame we can plot! Hooray!
dcfd_ors <- map_df(
  list(dcfd_mod),
  lrm_comparisons_addoutcome,
  df = model_df, getRatios = TRUE, vname = "trt", refVal = "C"
) %>%
  mutate(comp.c = fct_rev(factor(comp.c))) %>%
  ## Keep only one row for reference group
  distinct(ref, comp, effect, is.ref, .keep_all = TRUE)

ggplot(data = dcfd_ors, aes(y = effect, x = comp.c)) +
  ## Fake row to set up order properly
  geom_point(shape = NA) +
  ## Reference line at 1 (no effect)
  geom_hline(yintercept = 1, linetype = "solid",
             colour = palette_colors["lgray"], size = 2) +
  ## Plot a point for control group
  geom_point(shape = 15, colour = "black", size = 4,
             data = dcfd_ors %>% filter(comp.c == "C")) +
  ## Add ORs, CIs for treatment groups vs control
  geom_pointrange(
    aes(ymin = lcl, ymax = ucl),
    position = position_dodge(width = 0.5),
    shape = 16, size = 1, colour = as.character(palette_colors["dred"]),
    data = dcfd_ors %>% filter(comp.c != "C")
  ) +
  labs(
    title = "Treatment Group vs Delirium/Coma-Free Days",
    subtitle = glue(
      "P: {formatp(anova(dcfd_mod)['trt', 'P'])}"
    ),
    y = "Odds Ratio (95% Confidence Interval)",
    caption = "\nAdjusted analysis using proportional odds logistic regression."
  ) +
  theme(
    legend.position = "none",
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank(),
    plot.caption = element_text(size = basetext_size * 0.7)
  ) +
  coord_flip()

```

We also show the estimated median DCFDs (and 95% confidence interval) for a "typical" patient in each treatment group, with all covariate values set at the median or mode of our population.

```{r dcfd_medians}
## -- Use Liu's function to calculate conditional median, CI -------------------
## First: create newdata with median, mode values
## We can use datadist() to our advantage here. In the $limits element, the
##  second value for each variable is `Adjust to` and is by default the median
##  or mode.

pred_df_org <- map_dfc(
  setdiff(covariate_vars, "trt"),
  ~ as.data.frame(rep(dd$limits[2, .], times = length(levels(model_df$trt))))
) %>%
  set_names(setdiff(covariate_vars, "trt")) %>%
  bind_cols(data.frame(trt = levels(model_df$trt)))

pred_df_num <- pred_df_org %>%
  ## All columns need to be numeric because quantile.orm uses matrix algebra
  mutate_at(vars("arousal_rand", "trt"), as.numeric)

quantile.orm(
  mod = dcfd_mod,
  new.data = pred_df_org
)

quantile.orm(
  mod = dcfd_mod,
  new.data = pred_df_num
)

## Getting a nonconformability error; could this be due to factor variables?
## Save some things to an Rdata for Bryan

save(dcfd_mod, pred_df_org, pred_df_num, file = "quantile_orm_test.Rdata")

## Try using a model with only numeric, linear covariates, just in case
numeric_covars <- c("age_consent", "charlson_total", "iqcode_total_ph",
                    "frailty", "sofa_mod_imp_rand")
dcfd_linmod <- orm(
  as.formula(paste("dcfd_int", mod_rhs_lin, sep = " ~ ")),
  data = model_df,
  x = TRUE, y = TRUE
)

pred_df_num <- map_dfc(
  numeric_covars,
  ~ as.data.frame(rep(dd$limits[2, .], times = length(levels(model_df$trt))))
) %>%
  set_names(numeric_covars)


quantile.orm(dcfd_linmod, pred_df_num)

```

# Notes on Variable Calculation{#varcalc}

<hr>

## Severity of Illness{#soi}

Due to the nature of clinical data collection, we had some missing values for APACHE II and SOFA components despite our coordinators' best efforts. We handled these missing values in the following ways:

### APACHE II (ICU admission only)

- Oxygenation: If no arterial blood gas was done, we converted the lowest O2 saturation to PaO2 per the [EPIC II conversions](http://intensive.org/epic2/Documents/Estimation%20of%20PO2%20and%20FiO2.pdf) and assigned points based on PaO2 alone. O2 saturations below the lowest level included in the conversion table were assigned the lowest PaO2; O2 saturations of 100 were assigned the highest PaO2.
- pH: If no arterial blood gas was done, we used the serum HCO3 conversions noted in the original reference.
- Glasgow Coma Score: If no GCS was available, we assigned points for the APACHE using the lowest RASS on the day of ICU admission using the [Vasilevskis et al's](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4748963/) point values for the SOFA.
- All other components: If no values were available on a given day, we looked for a value on the closest day within the three full days after ICU admission. If none was available, we assumed that no measurement implied no clinical reason to suspect dysfunction, and assigned a normal value (0 points).

### SOFA (ICU admission + daily throughout intervention period)

- Substitutions for specific components:
    - Respiratory: If P/F ratio was not available, we used the lowest S/F ratio, per [Pandharipande et al](https://www.ncbi.nlm.nih.gov/pubmed/19242333).
    - Central nervous system: If no GCS was available, we used the lowest RASS available that day, per [Vasilevskis et al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4748963/), method C.
- Missing data at ICU admission:

    Using only data from ICU admission, there are `r sum(is.na(ptsummary_all_df$sofa_adm_only))` consented patients and  `r sum(is.na(ptsummary_df$sofa_adm_only))` randomized patients missing at least one SOFA component score. For these patients' missing components, we imputed the next available value within the following two calendar days. If none was available, we assumed a normal value (0 points). (This could happen either because there was no clinical reason to order labs, or because the patient was not consented within three days of ICU admission and thus no study data was collected in that period.)
    
- Missing data during the intervention period:
    - We were unable to calculate SOFA scores using raw data on `r sum(is.na(subset(daily_int_df, study_status == "Intervention")$sofa_raw))` patient-days during the study period (randomization + 13 days). *(Missingness is much higher after the official intervention/post-intervention periods, when patients were no longer being actively followed for daily data collection. However, in this analysis we are only concerned about the official 14-day study period.)*
    - If the data required to calculate a given component was unavailable, we imputed the closest non-missing component score before *or* after the missing day, up to two full days away (missing day +/-2 days). If data was available X days both before *and* after the missing day, we prioritized past over future values.
    - If, after this imputation, values are still missing, we assume that no available data indicates no clinical reason to suspect organ dysfunction and therefore impute a normal value for that component. Again, this applies to `r sum(is.na(subset(daily_int_df, study_status == "Intervention")$sofa_raw))` patient-days during the study period.
        
## Medications

- **Benzodiazepines** include midazolam, lorazepam, and/or diazepam. Doses are expressed in midazolam equivalents.
- **Opioids** include fentanyl, morphine, and/or hydromorphone. Doses are expressed in fentanyl equivalents.
- **Antipsychotics** include open-label haloperidol, open-label ziprasidone, quetiapine, aripiprazole, olanzapine (including in combination with fluoxetine), and/or risperidone. Doses are expressed in haloperidol equivalents.
- All conversion formulas can be found in [this spreadsheet](https://docs.google.com/spreadsheets/d/1ZGfxAmTFxGgfzjwE0trrpKEn_21QDwCSGJIv-E5kiE4/edit?usp=sharing).

## Mechanical Ventilation

During the course of the study, patients could be on invasive mechanical ventilation (MV), noninvasive positive pressure support (NIPPV), both, or neither. For our purposes, "time on MV" describes the number of days each patient was on *either* type of MV beginning at the time of randomization, **including** time between discontinuation of MV and reinitiation or death, if that time is less than 48 hours. (In other words, if a patient was extubated at 12pm and died at 3pm, those final three hours are included in the total time on MV.)

"Liberation from mechanical ventilation" indicates the first discontinuation of either type of MV which was followed by at least 48 hours alive without reinitiation of MV.

## Delirium/Coma-Free Days{#dcfds}

This primary outcome variable is calculated over the 14 days including and immediately following randomization. It is defined as days alive and without brain dysfunction.

### Determining Mental Status Using CAM and RASS

We determined mental status for a given *assessment* using the following criteria:

1. **Comatose**: RASS -4 or -5, **or** RASS missing and CAM Unable to Assess
1. **Delirious**: RASS missing or >= -3, and CAM Positive
1. **Normal**: RASS missing or >= -3, and CAM Negative

Patients could have multiple assessments on a given study day. On a given *day*, a patient was considered delirious if any assessment was considered delirious; comatose if no assessments met criteria for delirium and at least one was considered comatose; and normal if no assessments met criteria for delirium or coma, and at least one was considered normal.

### Handling Missing Data

Among all consented patients, `r sum(is.na(daily_all_df$mental_status_raw))` (`r round(mean(is.na(daily_all_df$mental_status_raw)) * 100)`%) in-hospital patient-days have insufficient information to determine mental status (due to missing data or study withdrawal).

Among randomized patients during the intervention period, `r sum(is.na(subset(daily_int_df, study_status == "Intervention")$mental_status_raw))` (`r round(mean(is.na(subset(daily_int_df, study_status == "Intervention")$mental_status_raw)) * 100)`%) of patient-days have missing mental status, again due either to missing data or study withdrawal.

Mental status can change quickly; therefore simple imputation methods like last observation carried forward could be inaccurate. Since we are fortunate to have strong covariate data, we performed single imputation using polytomous logistic regression, including the following variables as covariates in the imputation.

- **Baseline**: Age at consent; gender; BMI; education; level of proficiency in English; insurance; home antipsychotic use; Charlson comorbidities index; CSHA Clinical Frailty Score; APACHE II APS
- **Daily**:
    - Medications (clonazepam, dexmedetomidine, propofol, remifentanil, antipsychotics, benzodiazepines, opioids [IV and PO], antibiotics, anxiolytics, statins)
    - Variables indicating severity of illness (CV SOFA, creatinine, urine output, platelets, lowest recorded RASS, Glasgow Coma Scale, P/F ratio, S/F ratio, bilirubin)
    - Any mental status data available the day of, the day before, and the day after the missing day

All summary variables (delirium/coma-free days, delirium duration, and coma duration) are calculated using available and imputed mental status.

# Software Details

---

`r devtools::session_info()$platform$version` was used for all analyses. `r table_nums('package_info', display = 'cite')` shows all add-on packages loaded.

<details>

#### `r table_nums('package_info')`

```{r technical, results = 'asis'}
devtools::session_info()$packages %>%
  kable(
    format = "html",
    col.names = c("Package", "*", "Version", "Date", "Source")
  ) %>%
  mykablestyle(stripes = TRUE)

```
</details>